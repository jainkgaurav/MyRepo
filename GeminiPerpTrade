import requests
import json
import base64
import hmac
import hashlib
import datetime, time
import pandas as pd
import random
import ta
import configparser
from IPython.display import clear_output
import threading
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
#%matplotlib qt
import requests
from bs4 import BeautifulSoup
import json
import os
from pathlib import Path
#import schedule


    
def GetGitHubPriceSetupFile():
    file_content=''
    url = 'https://raw.githubusercontent.com/jainkgaurav/MyRepo/main/PriceSetup.ini'
    response = requests.get(url)
    if response.status_code == 200:
        # Content of the file
        file_content = response.text
    return file_content

def ProcessPriceSetupFileToLocal():
    filename = 'SymbolSetup.ini'
    try:
        if(can_rewrite(filename)==1):
            content = GetGitHubPriceSetupFile()
            if len(content)>0:
                with open(filename, 'w') as file:
                     file.write(content)
                     #write_to_log(content)
    except Exception as e:
        write_to_log(f'Error: {e}')
        
def can_rewrite(file_path):
    AllowUpdate=0
    try:
        # Get the last modification timestamp of the file
        last_modified_timestamp = os.path.getmtime(file_path)
        # Get the current time
        current_time = time.time()
        # Calculate the time difference in seconds
        time_difference = current_time - last_modified_timestamp
        # Check if the time difference is more than 1 hour (3600 seconds)
        if time_difference > 60:
           AllowUpdate=1
    except Exception as e:
        write_to_log(f'Error: {e}')
    return AllowUpdate

def data_to_write(content,symbol,filename):
    filename = filename+symbol+'.ini'
    with open(filename, 'w') as file:
        file.write('['+symbol+']\n')
        file.write(symbol+'='+str(content))

def data_to_write(content,symbol):
    filename = symbol+'TrailPrice.ini'
    with open(filename, 'w') as file:
        file.write('['+symbol+']\n')
        file.write(symbol+'='+str(content))


def write_to_log(*args):
    log_file_path = 'LogReport.log'
    max_file_size_kb = 10000

    current_time = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    log_entry = f'{current_time} - {" ".join(map(str, args))}\n'

    # Check file size
    if os.path.exists(log_file_path) and os.path.getsize(log_file_path) > max_file_size_kb * 1024:
        # If file size exceeds the threshold, create a new log file and delete the old one
        create_new_log(log_file_path)
    
    # Open the log file in append mode
    with open(log_file_path, 'a') as log_file:
        log_file.write(log_entry)


def create_new_log(old_log_path):
    # Create a new log file with a timestamp in the filename
    new_log_path = f'example_log_{datetime.datetime.now().strftime("%Y%m%d%H%M%S")}.txt'
    os.rename(old_log_path, new_log_path)
    os.remove(new_log_path)
    
def remove_file(symbol):
    # Check if the file exists before attempting to remove it
    filename = symbol+'TrailPrice.ini'
    if os.path.exists(filename):
        os.remove(filename)
  

# Function to generate a new nonce
def generate_nonce():
    #nonce = f'{int(time.time()) * 1000001 + int(time.perf_counter() * 1000001)}'
    t = datetime.datetime.now()
    nonce = time.time()
    #write_to_log(nonce)
    return nonce  # Convert current time to milliseconds

def read_config(filename='GeminiConfig.ini'):
    config = configparser.ConfigParser()
    config.read(filename)
    return config

# Read configuration file
config = read_config()

def MyPositions():
    payload_nounce = generate_nonce()
    payload = {'request': '/v1/balances', 'nonce': payload_nounce}
    return payload


def MyTrades():
    payload_nounce = generate_nonce()
    payload = {'request': '/v1/mytrades', 'nonce': payload_nounce}
    return payload

def NewOrder(SymbolScript='',Qty=0.00,ClientOrderID='', orderPrice=0, OrderType='LMT', BuyOrSell=''):
    payload_nounce = generate_nonce()
    #'client_order_id':ClientOrderID,
    match OrderType:
        case 'MC':
                OptionType='maker-or-cancel'
        case 'IC':
                OptionType='immediate-or-cancel'
        case 'FC':    
                OptionType='fill-or-kill'
        
    if OrderType  == 'LMT':
        payload = {
                'request': '/v1/order/new',
                'nonce': payload_nounce,
                'symbol': SymbolScript,
                'amount': str(Qty),
                'price': str(orderPrice),
                'side': BuyOrSell,
                'type': 'exchange limit'
                  }
    elif OrderType  == 'SL':
        payload = {
                'request': '/v1/order/new',
                'nonce': payload_nounce,
                'symbol': SymbolScript,
                'amount': str(Qty),
                'price': str(orderPrice),
                'side': BuyOrSell,
                'type': 'exchange stop limit'
                  }   
    else:
        payload = {
                'request': '/v1/order/new',
                'client_order_id':ClientOrderID,
                'nonce': payload_nounce,
                'symbol': SymbolScript,
                'amount': str(Qty),
                'price': str(orderPrice),
                'side': BuyOrSell,
                'type': 'exchange limit',
                'options' : [OptionType]
                  }
        
    return payload


def Auth(payload,isPrimary='N'):
    if isPrimary=='Y':
        gemini_api_key = config.get('GeminiAPI', 'PA_gemini_api_key')
        gemini_api_secret = config.get('GeminiAPI', 'PA_gemini_api_secret').encode()
    else:
        gemini_api_key = config.get('GeminiAPI', 'gemini_api_key')
        gemini_api_secret = config.get('GeminiAPI', 'gemini_api_secret').encode()
 
    payload['nonce'] = generate_nonce()
   
    encoded_payload = json.dumps(payload).encode()
    b64 = base64.b64encode(encoded_payload)
    # Ensure gemini_api_secret is represented as bytes
    signature = hmac.new(gemini_api_secret, b64, hashlib.sha384).hexdigest()
    request_headers = {
        'Content-Type': 'text/plain',
        'Content-Length': '0',
        'X-GEMINI-APIKEY': gemini_api_key,
        'X-GEMINI-PAYLOAD': b64.decode(),
        'X-GEMINI-SIGNATURE': signature,
        'Cache-Control': 'no-cache'
    }
    return request_headers

def getScriptPrice(symbol):
    base_url = 'https://api.gemini.com/v1'
    response = requests.get(base_url + '/pubticker/'+symbol)
    data = response.json()
    df = pd.DataFrame(data)
    return df

def getMidPrice(symbol):
    current_price = getScriptPrice(symbol)
    midPrice=current_price.values[0][1]
    return float(midPrice)
    
def GetMarkPriceOfETH():
    #mark_price
    response = RequestType('OP')
    data= response.json()
    df = pd.DataFrame(data)
    return df


def getOpenOrders():
    payload_nounce = generate_nonce()
    payload = { 'nonce': payload_nounce,'request': '/v1/orders'}
    return payload

def OpenPositions():
    payload_nounce = generate_nonce()
    payload = {  'request': '/v1/positions', 'nonce': payload_nounce,      }
    return payload

def CancelAllOrder():
    payload_nounce = generate_nonce()
    payload = {  'request': '/v1/order/cancel/all', 'nonce': payload_nounce    }
    return payload

def CancelOrder(order_id):
    payload_nounce = generate_nonce()
    payload = {
    "nonce": "payload_nounce",
    "order_id": order_id,
    "request": "/v1/order/cancel"
    }
    return payload



def isSymbolPresent(df, symbol):
    return symbol.lower() in df['symbol'].str.lower().values
    
def hasOpenOrders(symbol):
    df = RequestType('OO')  # 'OO' stands for Open Orders
    return int('symbol' in df.columns and df[df['symbol'] == symbol].shape[0] > 0)

def hasOpenPosition(symbol):
    df = RequestType('OP')  # 'OP' stands for Open Positions
    return int('symbol' in df.columns and df[df['symbol'] == symbol].shape[0] > 0)
   

def CloseAllOrders():
    open_orders = hasOpenOrders()

    if open_orders:
        for order in open_orders:
            order_id = order.get('order_id', None)
            if order_id:
                # Cancel the open order
                cancel_response = RequestType('CO', order_id)
                write_to_log(f'Canceled order {order_id}: {cancel_response.json()}')
    else:
        write_to_log('No open orders to close.')




# Add other functions as needed
def RequestType(strType, Symbol='',Qty=0.00,ClientOrderID='', orderPrice=0, OpType='', BuyOrSell='',OrderID=0):
    match strType:
        case 'Bal':
            url = 'https://api.gemini.com/v1/balances'
            request_headers=Auth(MyPositions())
            
        case 'MT':
            url = 'https://api.gemini.com/v1/mytrades'
            request_headers=Auth(MyTrades())
            
        case 'NO':
            url = 'https://api.gemini.com/v1/order/new'
            request_headers=Auth(NewOrder(Symbol,Qty,ClientOrderID, orderPrice, OpType, BuyOrSell))    

        case 'OO':
            write_to_log('Checking Open Orders...')
            url = 'https://api.gemini.com/v1/orders'
            request_headers=Auth(getOpenOrders())               
            
        
        case 'OP':
            url = 'https://api.gemini.com/v1/positions'
            request_headers=Auth(OpenPositions())        
            
        case 'CO':
            url = 'https://api.gemini.com/v1/order/cancel/all'
            request_headers=Auth(CancelAllOrder())   

        case 'CNCL':
            url = 'https://api.gemini.com/v1/order/cancel'
            request_headers=Auth(CancelOrder(OrderID))           
    
        case _:  write_to_log('Please provide correct input fuction')

    response = requests.post(url, headers=request_headers)
    data = response.json()
    #write_to_log('data : ',data)
    #data
   
    if isinstance(data, (list, dict)):
        # If the data is a list or dictionary, use DataFrame directly
        df = pd.DataFrame([data]) if isinstance(data, dict) else pd.DataFrame(data)
    else:
        # If the data is neither a list nor a dictionary, create a DataFrame with a single column
        df = pd.DataFrame({'data_column': [data]})

    
    #write_to_log(df)
    return df
	

def read_price_setup_from_csv(symbol):
    df = pd.read_csv('SymbolPriceLvlSetup.txt', dtype={'symbol':'string','side':'string','UpperRange':float,'LowerRange':float})
    price_ranges  = df[df['symbol'] == symbol] 
    return price_ranges
 

def GetMAVal(ConfigKey, MAPerid=100,period='5m',PriceBand=.0015):
    base_url = 'https://api.gemini.com/v2'
    response = requests.get(base_url + '/candles/'+ConfigKey+'/'+period)
    data = response.json()
    df=pd.DataFrame(data)
    # Create a dictionary to map numerical column names to labels
    column_mapping = {0: 'timestamp', 1: 'Open', 2: 'High', 3: 'Low', 4: 'Close', 5: 'Volume'}
    # Rename columns using the mapping
    df = df.rename(columns=column_mapping)
    #df['timestamp'] = pd.to_datetime(df['timestamp'])
    # Convert the timestamp column to datetime
    df['timestamp_ts'] = pd.to_datetime(df['timestamp'], unit='ms')
    df = df.sort_values(by='timestamp', ascending=True)  # Sort by timestamp in descending order
    df.set_index('timestamp', inplace=True)
    pd.set_option('display.float_format', '{:.2f}'.format)
    dfHA=CandleLogic(df,MAPerid,PriceBand)
    
    last_row = df.iloc[-1]
    #write_to_log(last_row)
    #return last_row
    
    return dfHA

    
def CandleLogic(df,MAPeriod,PriceBand):
    shift=20
    # Download historical data from Yahoo Finance
    df['HA_Open']  = (df['Open'].shift(1) + df['Close'].shift(1)) / 2
    df['HA_Close']  = (df['Open'] + df['Low'] + df['Close'] + df['High']) / 4
    df['HA_High']  = df[['High', 'Open', 'Close']].max(axis=1)
    df['HA_Low']  = df[['Low', 'Open', 'Close']].min(axis=1)
    df['HighRange'] = df['HA_High'].rolling(window=300).mean()
    df['LowRange'] = df['HA_Low'].rolling(window=300).mean()
    df["MAHLRange"]=(df['HighRange']-df['LowRange'])
    df["MAHLRatio"]=1-(df['HighRange']/df['LowRange'])
    df['MA'] = df['HA_Close'].rolling(window=MAPeriod).mean()
    df['UpperMA'] = df['MA']+df['MAHLRange'] 
    df['LowerMA'] = df['MA']-df['MAHLRange'] 
    df['IsGreen'] = np.where(df['HA_Open'] < df['HA_Close'], 'G', 'R') 
    df_cleaned = df.dropna()
    return df_cleaned
 
    
def get_symbol_data(symbol='BTC-USD', interval='15m', period='3d',MAPeriod=20 ,shift=1):
    heikin_ashi_df= getYahooData(symbol,interval,period,MAPeriod,shift)
    last_row = heikin_ashi_df.iloc[-1]
    #plotChar(heikin_ashi_df)
    write_to_log(last_row)
    return last_row

def plot(df):
    #df=getYahooData('ETH-USD', '5m', '3d',MAPeriod=50,shift=10)
    
    # Plotting OHLC data
    fig, ax = plt.subplots(figsize=(10, 6))
    
    ax.plot(df['LowerMA'], label='LowerMA', marker='',linewidth=1)
    ax.plot(df['UpperMA'], label='UpperMA', marker='',linewidth=1)
    ax.plot(df['MA'], label='MA', marker='',linewidth=1)
    ax.plot(df['Close'], label='Close', marker='',linewidth=1)
    
    ax.set_title('OHLC Chart')
    ax.set_xlabel('Index')
    ax.set_ylabel('Price')
    ax.legend()
    
    plt.show()
    
def calculate_hma(data, period):
    
    half_period = int(period / 2)

    wma_half = data.rolling(window=half_period).mean()
    wma_full = data.rolling(window=period).mean()

    weighted_moving_average = (2 * wma_half - wma_full).rolling(window=int(np.sqrt(period))).mean()
    
    return weighted_moving_average

def getYahooData(symbol, interval, period, MAPeriod=50,shift=10,BuyRange=.002):
    # Download historical data from Yahoo Finance
    df = yf.download(symbol, interval=interval, period=period)
    dfHA=CandleLogic(df,MAPeriod)
    return dfHA


def Get_Trailing_Stop(symbol,current_price, average_cost, OpenTradeQuantity,AllowTrailing,StopLossPerc,LongShortExit):
    TrailPrice=0
    write_to_log('******Updating Trailing**********')
    try:
        file_path = symbol+'TrailPrice.ini'
        file_path_obj = Path(file_path)
        if file_path_obj.exists():
            GetTrailConfig=read_config(filename=file_path)  
            TrailPrice= float(GetTrailConfig.get(symbol, symbol))
            write_to_log('******TrailPrice : *',TrailPrice)
    except (ValueError, KeyError, IndexError) as e:
        write_to_log(f'***Error in Getting Trail price: {e}****')
        TrailPrice=0
 
       
    if TrailPrice==0 or AllowTrailing=='N':
        TrailPrice=average_cost
    
    if OpenTradeQuantity>0:# For Closing Buy Position
       if AllowTrailing=='Y' and current_price/average_cost>1:
           TrailPrice= max(TrailPrice,current_price,average_cost)
 
       TrailPriceStopLoss=TrailPrice*(1-StopLossPerc)    
       if LongShortExit>0 and AllowTrailing!='Y' :# and LongExit>average_cost  : 
          TrailPriceStopLoss= LongShortExit 
          TrailPrice=average_cost
        
    elif OpenTradeQuantity<0: #For Closing Sell Position
       if AllowTrailing=='Y'  and average_cost/current_price>1:
           TrailPrice= min(TrailPrice,current_price,average_cost)
 
       TrailPriceStopLoss=TrailPrice*(1+StopLossPerc)    
       if LongShortExit>0 and AllowTrailing!='Y'  : #and ShortExit<average_cost :
          TrailPriceStopLoss= LongShortExit 
          TrailPrice=average_cost
 
     
    data_to_write(TrailPrice,symbol)     

    return TrailPriceStopLoss


def GetSetupParam(ConfigKey):
    '''Read setup parameters from a configuration file and return as a dictionary.'''
    config = read_config('SymbolSetup.ini')
    
    # Create a dictionary to store key-value pairs of setup parameters
    setup_params = {
        'correction': float(config.get('InitParam', 'Correction')),
        'MAPeriod': int(config.get('InitParam', 'MAPeriod')),
        'shift': int(config.get('InitParam', 'shift')),
        'InnerRangePerc' : float(config.get('InitParam', 'InnerRangePerc')),
        'OuterRangePerc' : float(config.get('InitParam', 'OuterRangePerc')),
        'TradeMethod' : float(config.get('InitParam', 'TradeMethod')),
        'BuyRange': float(config.get(ConfigKey, 'BuyRange')),
        'StopLossPerc': float(config.get(ConfigKey, 'StopLossPerc')),
        'TargetProftPerc': float(config.get(ConfigKey, 'TargetProftPerc')),
        'Qty': float(config.get(ConfigKey, 'Qty')),
        'InvestAmt': float(config.get(ConfigKey, 'InvestAmt')),
        'ClientOrderID': config.get(ConfigKey, 'ClientOrderID'),
        'Pair': config.get(ConfigKey, 'Pair'),
        'AllowTrading': config.get(ConfigKey, 'AllowTrading'),
        'LongExit': float(config.get(ConfigKey, 'LongExit')),
        'ShortExit': float(config.get(ConfigKey, 'ShortExit')),
        'AllowTrailing': config.get(ConfigKey, 'AllowTrailing'),
        'AlgoType': config.get(ConfigKey, 'AlgoType'),
        'PriceFactor': float(config.get(ConfigKey, 'PriceFactor')),
        'TrailStartAfterPerc': float(config.get(ConfigKey, 'TrailStartAfterPerc')),
        'LongEntry' : float(config.get(ConfigKey, 'LongEntry')),
        'ShortEntry' : float(config.get(ConfigKey, 'ShortEntry')),
        'DecimalPlace' : int(config.get(ConfigKey, 'DecimalPlace')),
        'QtyRounding' : int(config.get(ConfigKey, 'QtyRounding'))
        
       
        
    }
    
    return setup_params

def FormatNumber(val):
    return "{:.9f}".format(val)

def getBuySellCloseSignal(symbol,Timeperiod='15m'):
    
    TrailPrice=0.0
    TrailPriceStopLoss=0
    isBuyCondMatch=False
    isSellCondMatch=False
    LongEntry=0
    ShortEntry=0
    LongEntryRangeUp=0
    ShortEntryRangeDown=0
    signal=0

    try:
        write_to_log('************ StartTrading *******************')
        #dfOO = RequestType('OO') 
        #write_to_log(dfOO)
        ProcessPriceSetupFileToLocal()
        setup_params=GetSetupParam(symbol)
        current_price = getMidPrice(setup_params['Pair'] )  
        df=GetMAVal(setup_params['Pair'], MAPerid=setup_params['MAPeriod'],period=Timeperiod,PriceBand=setup_params['BuyRange'])

        last_row = df.iloc[-1]
        last_row1 = df.iloc[-2]
        last_row2 = df.iloc[-3]

        write_to_log('Candles : : ',last_row['IsGreen'] ,last_row1['IsGreen'] ,last_row2['IsGreen'] )
        

        TradeMethod=setup_params['TradeMethod']
        LongEntry = setup_params['LongEntry']
        ShortEntry =setup_params['ShortEntry']
        

        if TradeMethod=="FIX":
            UpperRang=LongEntry*(1+setup_params['BuyRange'])
            LowerRange=ShortEntry*(1-setup_params['BuyRange']) 
            isBuyCondMatch =   ( current_price>last_row["HA_High"]
                                  and
                                 current_price<UpperRang
                               )   
            isSellCondMatch = ( current_price<last_row["HA_Close"]
                                and 
                                current_price>LowerRange
                              )
            write_to_log('symbol,current_price,LongEntry,UpperRang,ShortEntry,LowerRange,isBuyCondMatch,isSellCondMatch,TradeMethod')
            write_to_log(symbol,current_price,LongEntry,UpperRang,ShortEntry,LowerRange,isBuyCondMatch,isSellCondMatch,TradeMethod)
    
        elif TradeMethod=="MA":
            InnerHighRange=last_row["MA"]*(1+setup_params['InnerRangePerc'])
            InnerLowRange=last_row["MA"]*(1-setup_params['InnerRangePerc']) 

            OuterHighRange=last_row["MA"] *(1+setup_params['OuterRangePerc'])
            OuterLowRange=last_row["MA"]*(1+setup_params['OuterRangePerc'])
            
            write_to_log("MA,InnerHighRange,InnerLowRange,OuterHighRange,OuterLowRange")
            write_to_log(last_row["MA"],InnerHighRange,InnerLowRange,OuterHighRange,OuterLowRange)
            IsInMARange=(current_price<InnerHighRange  and current_price>InnerLowRange)
        
            isBuyCondMatch =   (    last_row['IsGreen']=="G" 
                                    and last_row1['IsGreen']=="R" 
                                    and last_row2['IsGreen']=="R" 
                                    and current_price>last_row["HA_Close"]
                                    and current_price<last_row["HA_Close"]*(1+setup_params['BuyRange'])
                                    and (IsInMARange or current_price<OuterLowRange)
                                
                                )   

            isSellCondMatch = (
                                    last_row['IsGreen']=="R" 
                                    and last_row1['IsGreen']=="G" 
                                    and last_row2['IsGreen']=="G" 
                                    and current_price<last_row["HA_Close"]
                                    and current_price>last_row["HA_Close"]*(1-setup_params['BuyRange']) 
                                    and (IsInMARange or current_price>OuterHighRange)
                                )
        
            write_to_log('sysmbol,current_price,LongEntryRangeUp,LongEntry,ShortEntry,ShortEntryRangeDown,isBuyCondMatch,isSellCondMatch,TradeMethod')
            write_to_log(symbol,current_price,LongEntryRangeUp,LongEntry,ShortEntry,ShortEntryRangeDown,isBuyCondMatch,isSellCondMatch,TradeMethod)
            #write_to_log("last_row",last_row)
        
        if isBuyCondMatch:
            signal=1
        if isSellCondMatch:
            signal=-1    

    except (ValueError, KeyError, IndexError) as e:
        write_to_log(f'Error in getBuySellCloseSignal  Function : {e}')
        
    return signal   
    
def OpenCloseTrade(symbol):   
    if True:
        ProcessPriceSetupFileToLocal()
        setup_params=GetSetupParam(symbol)

        Updown=setup_params['correction']
        TrailPrice=0.0
        average_cost=0
        OpenTradeQuantity=0
        CloseSide=''
        CanClosePosition=False
        TrailPriceStopLoss=0
        mark_price=0.0
        CanOpenLimitOrders=False
        notional_value=0
        LimitOrderPrice=0
        IsLimitOrderOpen=False

        signal=  getBuySellCloseSignal(symbol,Timeperiod='15m')
        if signal==0:
            signal= getBuySellCloseSignal(symbol,Timeperiod='30m')
            write_to_log(symbol, " :30 minute signal check : ", signal)
             
        current_price = getMidPrice(setup_params['Pair'] )  
        dfOP = RequestType('OP') 
        write_to_log(dfOP)

        if not dfOP.empty: 
            filtered_dfOP = dfOP[dfOP['symbol'] == symbol]
            write_to_log('symbol : ',symbol)
            if len(filtered_dfOP)>0: #Close Existing Order
                #write_to_log('filtered_dfOP : /n',filtered_dfOP.iloc[-1])
                average_cost = float(filtered_dfOP['average_cost'].values[0])
                OpenTradeQuantity = float(filtered_dfOP['quantity'].values[0])
                unrealised_pnl=float(filtered_dfOP['unrealised_pnl'].values[0])
                mark_price=float(filtered_dfOP['mark_price'].values[0])
                notional_value=abs(float(filtered_dfOP['notional_value'].values[0]))

                write_to_log(" ***Amount Validation",notional_value>setup_params['InvestAmt']*.80)
                dfOpnOrders = RequestType('OO') 
                if dfOpnOrders.empty:
                    if notional_value>setup_params['InvestAmt']*.80:
                        CanOpenLimitOrders =True
                        write_to_log(symbol,"******Can Open new Limit Order ********")
                else :
                    dfOpnOrdersFilt = dfOpnOrders[dfOpnOrders['symbol'] == symbol]
                    write_to_log(" ***Check Limit Orders for ",symbol," *** ")
                    if dfOpnOrdersFilt.empty:
                        if notional_value>setup_params['InvestAmt']*.80:
                            CanOpenLimitOrders =True
                            write_to_log(symbol,"******Can Open new Limit Order ********")
                    else:    
                        write_to_log(symbol,"**Limit Orders are Present **")
                        for index, row in dfOpnOrdersFilt.iterrows():
                            write_to_log(row)

                if OpenTradeQuantity>0:# For Closing Buy Position
                    write_to_log('****1.checking open orders')    
                    CloseSide='sell' 
                    Updown=setup_params['correction']
                    TrailPriceStopLoss=Get_Trailing_Stop(symbol,mark_price, average_cost, OpenTradeQuantity,setup_params['AllowTrailing'],setup_params['StopLossPerc'],setup_params['LongExit'])
                    LimitOrderPrice=round(average_cost*(1+setup_params['StopLossPerc']),setup_params['DecimalPlace'])
                    #TrailPriceStopLoss=max(ShortEntryUB,TrailPrice)
                    CanClosePosition=  ( TrailPriceStopLoss > mark_price or current_price/average_cost>setup_params['TargetProftPerc'])
                    
                elif OpenTradeQuantity<0: #For Closing Sell Position
                    CloseSide='buy'
                    Updown=-setup_params['correction']
                    #if(mark_price<average_cost):
                    LimitOrderPrice=round(average_cost*(1-setup_params['StopLossPerc']),setup_params['DecimalPlace'])

                    TrailPriceStopLoss=Get_Trailing_Stop(symbol,current_price, average_cost, OpenTradeQuantity,setup_params['AllowTrailing'],setup_params['StopLossPerc'],setup_params['ShortExit'])
                    #TrailPriceStopLoss=min(LongEntryLB,TrailPrice)
                    CanClosePosition= (TrailPriceStopLoss < mark_price or average_cost/mark_price>setup_params['TargetProftPerc'] )
        
                write_to_log('CanOpenLimitOrders,CanClosePosition,OpenTradeQuantity,average_cost  TrailPriceStopLoss: ',
                             CanOpenLimitOrders,CanClosePosition,FormatNumber(OpenTradeQuantity),
                             FormatNumber(average_cost), FormatNumber(TrailPriceStopLoss))
                try: 
                    #*************CLOSING  ORDER*****************************
                    if  (CanClosePosition) :
                        dfOpnOrders = RequestType('OO') 
                        if not dfOpnOrders.empty:
                            dfOpnOrdersFilt = dfOpnOrders[dfOpnOrders['symbol'] == symbol]
                            if not dfOpnOrdersFilt.empty:
                                for index, row in dfOpnOrdersFilt.iterrows():
                                    write_to_log(row)
                                    write_to_log(symbol,"******Canceling Orders ********")
                                    RequestType('CNCL', OrderID=row['order_id'])

                        write_to_log(symbol,'========================Close Position==========================================')
                        orderPrice =round(getMidPrice(setup_params['Pair'])*(1-Updown),setup_params['DecimalPlace'])
                        write_to_log(symbol, " Close Order price and Qty",FormatNumber(orderPrice),abs(OpenTradeQuantity))
                        data = RequestType('NO',Symbol=symbol,
                                           Qty=abs(OpenTradeQuantity),
                                           ClientOrderID=setup_params['ClientOrderID'], 
                                           orderPrice=orderPrice ,
                                           OpType='LMT',
                                           BuyOrSell=CloseSide)
                        write_to_log('Close Position Step2:', data.iloc[-1])

                    #*************OPENING LIMIT ORDER*****************************
                    if (CanOpenLimitOrders and LimitOrderPrice>0 and unrealised_pnl>0):
                        QtyLimit1=round(setup_params['InvestAmt']*(0.55)/current_price,setup_params['QtyRounding'])
                        write_to_log(symbol,'========================Limit Order 1==========================================')
                        data = RequestType('NO',Symbol=symbol,Qty=abs(QtyLimit1),
                                            ClientOrderID=setup_params['ClientOrderID'], 
                                            orderPrice=LimitOrderPrice,
                                            OpType='LMT',
                                            BuyOrSell=CloseSide)
                        write_to_log('\Limit Order Position Step2:', data.iloc[-1])    

                except (ValueError, KeyError, IndexError) as e:
                    write_to_log(f'Error in =====Close Position===: {e}')
                       
            else:
                dfOpnOrders = RequestType('OO') 
                if not dfOpnOrders.empty:
                    dfOpnOrdersFilt = dfOpnOrders[dfOpnOrders['symbol'] == symbol]
                    if not dfOpnOrdersFilt.empty:
                        for index, row in dfOpnOrdersFilt.iterrows():
                            write_to_log(row)
                            write_to_log(symbol,"******Canceling Orders ********")
                            RequestType('CNCL', OrderID=row['order_id'])
                            

                    #write_to_log(dfOPLastRow)
        if OpenTradeQuantity==0:
            data_to_write(current_price,symbol)   

        #CloseAllOpenOrdersForSymbol
        write_to_log(symbol, " *** 15 minute signal ***: ", signal)

        if(signal==1 or signal==-1) and OpenTradeQuantity==0 and setup_params['AllowTrading']=='Y'  :
            write_to_log('========================Open New Position==========================================')
            write_to_log("Test1")

            current_price = getMidPrice(setup_params['Pair']) 
            data_to_write(current_price,symbol)     
            correction_factor = 1 + setup_params['correction']
            buysellind = 'buy'
            write_to_log("Test2")
            Qty=round(setup_params['InvestAmt']/current_price,setup_params['QtyRounding'])
            if signal==-1: 
                buysellind ='sell'
                correction_factor = 1 - setup_params['correction']
            write_to_log("Test3")
            df = RequestType('NO',Symbol=symbol,Qty= Qty,ClientOrderID=setup_params['ClientOrderID'],
                                orderPrice=round(current_price * correction_factor, setup_params['DecimalPlace']),
                            OpType='FC',BuyOrSell=buysellind)
            
            write_to_log('New {buysellind} Order Response:', df.iloc[-1])  
           
    
def open_close_trade(symbol):
    #try:
    if True:    
        time.sleep(1)
        LogFileName="ethgusdperp_log.log"
        write_to_log(f'************ {symbol.upper()} *******************')
        OpenCloseTrade(symbol)
    #except Exception as e:
    #    write_to_log(f'An exception occurred: {e}')


def Tradejob():
    while True:
        write_to_log('************ Thread Started *******************')
        ProcessPriceSetupFileToLocal()
        current_time = datetime.datetime.now()
        write_to_log('Current Time:', current_time) 
        
        try:
            dfBal = RequestType('Bal')
            filtered_dfBal = dfBal[dfBal['currency'] == 'GUSD']
            write_to_log(filtered_dfBal)
        except Exception as e:
            write_to_log(f'An exception occurred: {e}')

        
        open_close_trade('ethgusdperp')
        
        open_close_trade('btcgusdperp')
        
        open_close_trade('solgusdperp')
        #open_close_trade('pepegusdperp')
        #open_close_trade('maticgusdperp')

        if current_time.minute % 15 == 0:
            clear_output(wait=True)

def test():
    # sleep for 30 Seconds
    #write_to_log(getYahooData('ETH-USD', '5m', '3d', MAPeriod=10))
    write_to_log('Initiated....')
    symbol='ethgusdperp'
    setup_params=GetSetupParam(symbol)
    write_to_log(setup_params)
    current_price = getMidPrice(setup_params['Pair']) 
 
    df=GetMAVal(setup_params['Pair'], MAPerid=setup_params['MAPeriod'],period='1hr',PriceBand=setup_params['BuyRange'])
    #plot(df.tail(5))
    write_to_log(df.tail(5))
    write_to_log('current_price : ',current_price)
    OpenCloseTrade('ethgusdperp')
    

if __name__ == '__main__':
    LogFileName=""
    #test()
    # sleep for 30 Seconds
    write_to_log('Initiated....')
    Tradejob()
  
